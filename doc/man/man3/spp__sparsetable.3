.TH "spp_::sparsetable< T, Alloc >" 3 "Mon Apr 23 2018" "Version 0.0.1" "OpenISA Dynamic Binary Translator" \" -*- nroff -*-
.ad l
.nh
.SH NAME
spp_::sparsetable< T, Alloc > \- 
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBGrpPos\fP"
.br
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef T \fBvalue_type\fP"
.br
.ti -1c
.RI "typedef Alloc \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef \fBsparsegroup\fP< value_type, allocator_type > \fBgroup_type\fP"
.br
.ti -1c
.RI "typedef allocator_type::size_type \fBsize_type\fP"
.br
.ti -1c
.RI "typedef allocator_type::difference_type \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef value_type & \fBreference\fP"
.br
.ti -1c
.RI "typedef const value_type & \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef value_type * \fBpointer\fP"
.br
.ti -1c
.RI "typedef const value_type * \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef \fBgroup_type\fP & \fBGroupsReference\fP"
.br
.ti -1c
.RI "typedef const \fBgroup_type\fP & \fBGroupsConstReference\fP"
.br
.ti -1c
.RI "typedef group_type::ne_iterator \fBColIterator\fP"
.br
.ti -1c
.RI "typedef group_type::const_ne_iterator \fBColConstIterator\fP"
.br
.ti -1c
.RI "typedef \fBtable_iterator\fP< \fBsparsetable\fP< T, allocator_type > > \fBiterator\fP"
.br
.ti -1c
.RI "typedef \fBconst_table_iterator\fP< \fBsparsetable\fP< T, allocator_type > > \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef std::reverse_iterator< \fBconst_iterator\fP > \fBconst_reverse_iterator\fP"
.br
.ti -1c
.RI "typedef std::reverse_iterator< \fBiterator\fP > \fBreverse_iterator\fP"
.br
.ti -1c
.RI "typedef \fBTwo_d_iterator\fP< T, \fBgroup_type\fP *, ColIterator, std::bidirectional_iterator_tag > \fBne_iterator\fP"
.br
.ti -1c
.RI "typedef \fBTwo_d_iterator\fP< const T, const \fBgroup_type\fP *, ColConstIterator, std::bidirectional_iterator_tag > \fBconst_ne_iterator\fP"
.br
.ti -1c
.RI "typedef \fBTwo_d_destructive_iterator\fP< T, \fBgroup_type\fP *, ColIterator, std::input_iterator_tag, allocator_type > \fBdestructive_iterator\fP"
.br
.ti -1c
.RI "typedef std::reverse_iterator< \fBne_iterator\fP > \fBreverse_ne_iterator\fP"
.br
.ti -1c
.RI "typedef std::reverse_iterator< \fBconst_ne_iterator\fP > \fBconst_reverse_ne_iterator\fP"
.br
.ti -1c
.RI "typedef \fBsparsehash_internal::pod_serializer\fP< value_type > \fBNopointerSerializer\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP ()"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBbegin\fP () const "
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcbegin\fP () const "
.br
.ti -1c
.RI "\fBiterator\fP \fBend\fP ()"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBend\fP () const "
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcend\fP () const "
.br
.ti -1c
.RI "reverse_iterator \fBrbegin\fP ()"
.br
.ti -1c
.RI "const_reverse_iterator \fBrbegin\fP () const "
.br
.ti -1c
.RI "const_reverse_iterator \fBcrbegin\fP () const "
.br
.ti -1c
.RI "reverse_iterator \fBrend\fP ()"
.br
.ti -1c
.RI "const_reverse_iterator \fBrend\fP () const "
.br
.ti -1c
.RI "const_reverse_iterator \fBcrend\fP () const "
.br
.ti -1c
.RI "\fBne_iterator\fP \fBne_begin\fP ()"
.br
.ti -1c
.RI "\fBconst_ne_iterator\fP \fBne_begin\fP () const "
.br
.ti -1c
.RI "\fBconst_ne_iterator\fP \fBne_cbegin\fP () const "
.br
.ti -1c
.RI "\fBne_iterator\fP \fBne_end\fP ()"
.br
.ti -1c
.RI "\fBconst_ne_iterator\fP \fBne_end\fP () const "
.br
.ti -1c
.RI "\fBconst_ne_iterator\fP \fBne_cend\fP () const "
.br
.ti -1c
.RI "reverse_ne_iterator \fBne_rbegin\fP ()"
.br
.ti -1c
.RI "const_reverse_ne_iterator \fBne_rbegin\fP () const "
.br
.ti -1c
.RI "const_reverse_ne_iterator \fBne_crbegin\fP () const "
.br
.ti -1c
.RI "reverse_ne_iterator \fBne_rend\fP ()"
.br
.ti -1c
.RI "const_reverse_ne_iterator \fBne_rend\fP () const "
.br
.ti -1c
.RI "const_reverse_ne_iterator \fBne_crend\fP () const "
.br
.ti -1c
.RI "\fBdestructive_iterator\fP \fBdestructive_begin\fP ()"
.br
.ti -1c
.RI "\fBdestructive_iterator\fP \fBdestructive_end\fP ()"
.br
.ti -1c
.RI "group_type::size_type \fBpos_in_group\fP (size_type i) const "
.br
.ti -1c
.RI "size_type \fBgroup_num\fP (size_type i) const "
.br
.ti -1c
.RI "\fBGroupsReference\fP \fBwhich_group\fP (size_type i)"
.br
.ti -1c
.RI "\fBGroupsConstReference\fP \fBwhich_group\fP (size_type i) const "
.br
.ti -1c
.RI "void \fB_alloc_group_array\fP (group_size_type sz, \fBgroup_type\fP *&first, \fBgroup_type\fP *&last)"
.br
.ti -1c
.RI "void \fB_free_group_array\fP (\fBgroup_type\fP *&first, \fBgroup_type\fP *&last)"
.br
.ti -1c
.RI "void \fB_allocate_groups\fP (size_type sz)"
.br
.ti -1c
.RI "void \fB_free_groups\fP ()"
.br
.ti -1c
.RI "void \fB_cleanup\fP ()"
.br
.ti -1c
.RI "void \fB_init\fP ()"
.br
.ti -1c
.RI "void \fB_copy\fP (const \fBsparsetable\fP &o)"
.br
.ti -1c
.RI "\fBsparsetable\fP (size_type sz=0, const allocator_type &alloc=allocator_type())"
.br
.ti -1c
.RI "\fBsparsetable\fP (const \fBsparsetable\fP &o)"
.br
.ti -1c
.RI "\fBsparsetable\fP & \fBoperator=\fP (const \fBsparsetable\fP &o)"
.br
.ti -1c
.RI "\fBsparsetable\fP (\fBsparsetable\fP &&o)"
.br
.ti -1c
.RI "\fBsparsetable\fP (\fBsparsetable\fP &&o, const allocator_type &alloc)"
.br
.ti -1c
.RI "\fBsparsetable\fP & \fBoperator=\fP (\fBsparsetable\fP &&o)"
.br
.ti -1c
.RI "void \fBswap\fP (\fBsparsetable\fP &o)"
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "allocator_type \fBget_allocator\fP () const "
.br
.ti -1c
.RI "size_type \fBsize\fP () const "
.br
.ti -1c
.RI "size_type \fBmax_size\fP () const "
.br
.ti -1c
.RI "bool \fBempty\fP () const "
.br
.ti -1c
.RI "size_type \fBnum_nonempty\fP () const "
.br
.ti -1c
.RI "void \fBresize\fP (size_type new_size)"
.br
.ti -1c
.RI "bool \fBtest\fP (size_type i) const "
.br
.ti -1c
.RI "bool \fBtest_strict\fP (size_type i) const "
.br
.ti -1c
.RI "bool \fBtest\fP (\fBiterator\fP pos) const "
.br
.ti -1c
.RI "bool \fBtest\fP (\fBconst_iterator\fP pos) const "
.br
.ti -1c
.RI "reference \fBunsafe_get\fP (size_type i) const "
.br
.ti -1c
.RI "\fBconst_ne_iterator\fP \fBget_iter\fP (size_type i) const "
.br
.ti -1c
.RI "\fBconst_ne_iterator\fP \fBget_iter\fP (size_type i, ColIterator col_it) const "
.br
.ti -1c
.RI "\fBne_iterator\fP \fBget_iter\fP (size_type i)"
.br
.ti -1c
.RI "\fBne_iterator\fP \fBget_iter\fP (size_type i, ColIterator col_it)"
.br
.ti -1c
.RI "size_type \fBget_pos\fP (const \fBconst_ne_iterator\fP &it) const "
.br
.ti -1c
.RI "template<class Val > reference \fBset\fP (size_type i, Val &val)"
.br
.ti -1c
.RI "void \fBmove\fP (size_type i, reference val)"
.br
.ti -1c
.RI "void \fBerase\fP (size_type i)"
.br
.ti -1c
.RI "void \fBerase\fP (\fBiterator\fP pos)"
.br
.ti -1c
.RI "void \fBerase\fP (\fBiterator\fP start_it, \fBiterator\fP end_it)"
.br
.ti -1c
.RI "\fBconst_ne_iterator\fP \fBerase\fP (\fBconst_ne_iterator\fP it)"
.br
.ti -1c
.RI "\fBconst_ne_iterator\fP \fBerase\fP (\fBconst_ne_iterator\fP f, \fBconst_ne_iterator\fP l)"
.br
.ti -1c
.RI "template<typename OUTPUT > bool \fBwrite_metadata\fP (OUTPUT *fp) const "
.br
.ti -1c
.RI "template<typename INPUT > bool \fBread_metadata\fP (INPUT *fp)"
.br
.ti -1c
.RI "bool \fBwrite_nopointer_data\fP (FILE *fp) const "
.br
.ti -1c
.RI "bool \fBread_nopointer_data\fP (FILE *fp)"
.br
.ti -1c
.RI "template<typename ValueSerializer , typename OUTPUT > bool \fBserialize\fP (ValueSerializer serializer, OUTPUT *fp)"
.br
.ti -1c
.RI "template<typename ValueSerializer , typename INPUT > bool \fBunserialize\fP (ValueSerializer serializer, INPUT *fp)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBsparsetable\fP &x) const "
.br
.ti -1c
.RI "bool \fBoperator<\fP (const \fBsparsetable\fP &x) const "
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBsparsetable\fP &x) const "
.br
.ti -1c
.RI "bool \fBoperator<=\fP (const \fBsparsetable\fP &x) const "
.br
.ti -1c
.RI "bool \fBoperator>\fP (const \fBsparsetable\fP &x) const "
.br
.ti -1c
.RI "bool \fBoperator>=\fP (const \fBsparsetable\fP &x) const "
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static group_size_type \fBnum_groups\fP (size_type num)"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "struct \fBGrpPos\fP"
.br
.in -1c

.SH "Author"
.PP 
Generated automatically by Doxygen for OpenISA Dynamic Binary Translator from the source code\&.
