.TH "spp_::sparse_hashtable< Value, Key, HashFcn, ExtractKey, SetKey, EqualKey, Alloc >" 3 "Mon Apr 23 2018" "Version 0.0.1" "OpenISA Dynamic Binary Translator" \" -*- nroff -*-
.ad l
.nh
.SH NAME
spp_::sparse_hashtable< Value, Key, HashFcn, ExtractKey, SetKey, EqualKey, Alloc > \- 
.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef Key \fBkey_type\fP"
.br
.ti -1c
.RI "typedef Value \fBvalue_type\fP"
.br
.ti -1c
.RI "typedef HashFcn \fBhasher\fP"
.br
.ti -1c
.RI "typedef EqualKey \fBkey_equal\fP"
.br
.ti -1c
.RI "typedef Alloc \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef allocator_type::size_type \fBsize_type\fP"
.br
.ti -1c
.RI "typedef allocator_type::difference_type \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef value_type & \fBreference\fP"
.br
.ti -1c
.RI "typedef const value_type & \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef value_type * \fBpointer\fP"
.br
.ti -1c
.RI "typedef const value_type * \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef \fBsparsetable\fP< value_type, allocator_type > \fBTable\fP"
.br
.ti -1c
.RI "typedef \fBTable::ne_iterator\fP \fBne_it\fP"
.br
.ti -1c
.RI "typedef \fBTable::const_ne_iterator\fP \fBcne_it\fP"
.br
.ti -1c
.RI "typedef \fBTable::destructive_iterator\fP \fBdest_it\fP"
.br
.ti -1c
.RI "typedef Table::ColIterator \fBColIterator\fP"
.br
.ti -1c
.RI "typedef \fBne_it\fP \fBiterator\fP"
.br
.ti -1c
.RI "typedef \fBcne_it\fP \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef \fBdest_it\fP \fBdestructive_iterator\fP"
.br
.ti -1c
.RI "typedef \fBiterator\fP \fBlocal_iterator\fP"
.br
.ti -1c
.RI "typedef \fBconst_iterator\fP \fBconst_local_iterator\fP"
.br
.ti -1c
.RI "typedef \fBsparsehash_internal::pod_serializer\fP< value_type > \fBNopointerSerializer\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP ()"
.br
.ti -1c
.RI "\fBiterator\fP \fBend\fP ()"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBbegin\fP () const "
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBend\fP () const "
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcbegin\fP () const "
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcend\fP () const "
.br
.ti -1c
.RI "\fBlocal_iterator\fP \fBbegin\fP (size_type i)"
.br
.ti -1c
.RI "\fBlocal_iterator\fP \fBend\fP (size_type i)"
.br
.ti -1c
.RI "\fBconst_local_iterator\fP \fBbegin\fP (size_type i) const "
.br
.ti -1c
.RI "\fBconst_local_iterator\fP \fBend\fP (size_type i) const "
.br
.ti -1c
.RI "\fBconst_local_iterator\fP \fBcbegin\fP (size_type i) const "
.br
.ti -1c
.RI "\fBconst_local_iterator\fP \fBcend\fP (size_type i) const "
.br
.ti -1c
.RI "\fBdestructive_iterator\fP \fBdestructive_begin\fP ()"
.br
.ti -1c
.RI "\fBdestructive_iterator\fP \fBdestructive_end\fP ()"
.br
.ti -1c
.RI "hasher \fBhash_funct\fP () const "
.br
.ti -1c
.RI "key_equal \fBkey_eq\fP () const "
.br
.ti -1c
.RI "allocator_type \fBget_allocator\fP () const "
.br
.ti -1c
.RI "unsigned int \fBnum_table_copies\fP () const "
.br
.ti -1c
.RI "size_type \fBsize\fP () const "
.br
.ti -1c
.RI "size_type \fBmax_size\fP () const "
.br
.ti -1c
.RI "bool \fBempty\fP () const "
.br
.ti -1c
.RI "size_type \fBbucket_count\fP () const "
.br
.ti -1c
.RI "size_type \fBmax_bucket_count\fP () const "
.br
.ti -1c
.RI "size_type \fBbucket_size\fP (size_type i) const "
.br
.ti -1c
.RI "void \fBresize\fP (size_type req_elements)"
.br
.ti -1c
.RI "void \fBget_resizing_parameters\fP (float *shrink, float *grow) const "
.br
.ti -1c
.RI "float \fBget_shrink_factor\fP () const "
.br
.ti -1c
.RI "float \fBget_enlarge_factor\fP () const "
.br
.ti -1c
.RI "void \fBset_resizing_parameters\fP (float shrink, float grow)"
.br
.ti -1c
.RI "void \fBset_shrink_factor\fP (float shrink)"
.br
.ti -1c
.RI "void \fBset_enlarge_factor\fP (float grow)"
.br
.ti -1c
.RI "\fBsparse_hashtable\fP (size_type expected_max_items_in_table=0, const HashFcn &hf=HashFcn(), const EqualKey &eql=EqualKey(), const ExtractKey &ext=ExtractKey(), const SetKey &set=SetKey(), const allocator_type &alloc=allocator_type())"
.br
.ti -1c
.RI "\fBsparse_hashtable\fP (const \fBsparse_hashtable\fP &ht, size_type min_buckets_wanted=HT_DEFAULT_STARTING_BUCKETS)"
.br
.ti -1c
.RI "\fBsparse_hashtable\fP (\fBsparse_hashtable\fP &&o)"
.br
.ti -1c
.RI "\fBsparse_hashtable\fP (\fBsparse_hashtable\fP &&o, const allocator_type &alloc)"
.br
.ti -1c
.RI "\fBsparse_hashtable\fP & \fBoperator=\fP (\fBsparse_hashtable\fP &&o)"
.br
.ti -1c
.RI "\fBsparse_hashtable\fP (MoveDontCopyT mover, \fBsparse_hashtable\fP &ht, size_type min_buckets_wanted=HT_DEFAULT_STARTING_BUCKETS)"
.br
.ti -1c
.RI "\fBsparse_hashtable\fP & \fBoperator=\fP (const \fBsparse_hashtable\fP &ht)"
.br
.ti -1c
.RI "void \fBswap\fP (\fBsparse_hashtable\fP &ht)"
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "\fBiterator\fP \fBfind\fP (const key_type &key)"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBfind\fP (const key_type &key) const "
.br
.ti -1c
.RI "size_type \fBbucket\fP (const key_type &key) const "
.br
.ti -1c
.RI "size_type \fBcount\fP (const key_type &key) const "
.br
.ti -1c
.RI "std::pair< \fBiterator\fP, \fBiterator\fP > \fBequal_range\fP (const key_type &key)"
.br
.ti -1c
.RI "std::pair< \fBconst_iterator\fP, \fBconst_iterator\fP > \fBequal_range\fP (const key_type &key) const "
.br
.ti -1c
.RI "template<class\&.\&.\&. Args> std::pair< \fBiterator\fP, bool > \fBemplace\fP (Args &&\&.\&.\&.args)"
.br
.ti -1c
.RI "std::pair< \fBiterator\fP, bool > \fBinsert\fP (const_reference obj)"
.br
.ti -1c
.RI "template<class P > std::pair< \fBiterator\fP, bool > \fBinsert\fP (P &&obj)"
.br
.ti -1c
.RI "template<class InputIterator > void \fBinsert\fP (InputIterator f, InputIterator l)"
.br
.ti -1c
.RI "template<class DefaultValue > value_type & \fBfind_or_insert\fP (const key_type &key)"
.br
.ti -1c
.RI "size_type \fBerase\fP (const key_type &key)"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBerase\fP (\fBconst_iterator\fP pos)"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBerase\fP (\fBconst_iterator\fP f, \fBconst_iterator\fP l)"
.br
.ti -1c
.RI "void \fBset_deleted_key\fP (const key_type &)"
.br
.ti -1c
.RI "void \fBclear_deleted_key\fP ()"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBsparse_hashtable\fP &ht) const "
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBsparse_hashtable\fP &ht) const "
.br
.ti -1c
.RI "template<typename OUTPUT > bool \fBwrite_metadata\fP (OUTPUT *fp)"
.br
.ti -1c
.RI "template<typename INPUT > bool \fBread_metadata\fP (INPUT *fp)"
.br
.ti -1c
.RI "template<typename OUTPUT > bool \fBwrite_nopointer_data\fP (OUTPUT *fp)"
.br
.ti -1c
.RI "template<typename INPUT > bool \fBread_nopointer_data\fP (INPUT *fp)"
.br
.ti -1c
.RI "template<typename ValueSerializer , typename OUTPUT > bool \fBserialize\fP (ValueSerializer serializer, OUTPUT *fp)"
.br
.ti -1c
.RI "template<typename ValueSerializer , typename INPUT > bool \fBunserialize\fP (ValueSerializer serializer, INPUT *fp)"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const int \fBHT_OCCUPANCY_PCT\fP = 50"
.br
.ti -1c
.RI "static const int \fBHT_EMPTY_PCT\fP"
.br
.ti -1c
.RI "static const size_type \fBHT_MIN_BUCKETS\fP = 4"
.br
.ti -1c
.RI "static const size_type \fBHT_DEFAULT_STARTING_BUCKETS\fP = 32"
.br
.in -1c
.SH "Member Data Documentation"
.PP 
.SS "template<class Value, class Key, class HashFcn, class ExtractKey, class SetKey, class EqualKey, class Alloc> const int \fBspp_::sparse_hashtable\fP< V, K, HF, ExK, SetK, EqK, A >::HT_EMPTY_PCT\fC [static]\fP"
\fBInitial value:\fP
.PP
.nf
= static_cast<int>(0\&.4 *
                   sparse_hashtable<V,K,HF,ExK,SetK,EqK,A>::HT_OCCUPANCY_PCT)
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for OpenISA Dynamic Binary Translator from the source code\&.
